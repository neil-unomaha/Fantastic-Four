# Summary of Observations

We analyzed the threat list generated by the TMT prorgram in order to determine if these threats are already mitigated in mosquitto.  Below are our findings after reviewing the mosquitto documentation and performing a code review.

## Spoofing: 
Mosquitto does have username/password authentication built in.  If the username/password feature is enabled, there are two ways to setup the credentials: 
* A system admin can do this manually.  If they do this, they still need to use the `mosquitto_passwd` utility with the `-U` option in order to hash the passwords in the file. 
* Use the `mosquitto_passwd` utility to manage the file. This utlility can create and update the password file.

The password utility must be performed on the same machine as the mosquitto broker.  It does not allow remote access since it is not exposed to the open internet.  This is a good security mechanism which prevents a significant amount of potential attack vectors.

Mosquitto has a strict format for the password file.  Each line must only have 1024 bytes worth of characters. This strict format is important because it prevents buffer overflows within the code.  Any line in the password file, or username/password argument passed into the "mosquitto_passwd" utility, that is longer than 1024 characters will be cut off when read by the mosquitto_passwd program.  This length is specified in the `MAX_BUFFER_LEN` preprocessor in the "moquitto_passwd.c" file, and it is referenced repeatedly througout the file, including in the `delete_pwuser` function, `update_pwuser` function, and the `get_password` file.   

Mosquitto does provide the “allow_anonymous”  configuration flag to enforce a “closed system.” 

One of our findings was that mosquitto does not require strong passwords.  This leaves open the possability for a brute force attack.  

Mosquitto also supports dual factor authentication.  In addition to username/password authentication, the system admin can also setup pre-shared-key based encryption.  

## Tampering:
We saw evidence throughout the project that input validation is repeatedly enforced in order to prevent the possability of buffer overflows.   Methods associated with buffer overflows because they do no bounds checking, `gets()`, `scanf()` and `strcpy()`, are not referenced anywhere in the repository.  The method `strcat()` which does no bounds checking is referenced twice in the "service.c" file, but it is safe because the argument in question is a predetermined string literal.  The code makes good use of methods that require an argument to be passed for the length of data structures,  such as: `calloc()`, `memcpy()`, and `strncpy()`. Two files of particular interest for tampering purposes is the "handle_publish.c" file and the "handle_subscribe.c" file.  Buffer Overflow preventions are present in both files.  Specifically, lines 155, 156, 157, 138-145 in "handle_publish.c," and lines 52, 139 on "handle_subscribe.c."  

## Repudiation:
Mosquitto enforces the MQTT feature of "Quality of Service".  Quality of Service refers to how hard Mosquitto will work to deliver the message to subscribers.  For purposes of mitigating repudiation, level 1 and level 2 would be considered the best strategies.  Level one will continue sending the message until a confirmation is receieved, and Level 2 sends the message exactly once, but a four step handshake establishes a connectiona nd acknwledges that the data was received. 

## Information Disclosure:
Information disclosure attacks are mitigated with built-in support for network level encryption via SSL/TLS support. This configuration is disabled by default and must be setup by the system admin. 

## Denial of Service

## Elevation of Privilege
Mosquitto protects against elevation of privilege attacks by implementing an access control list.  The major access control list functions are located in the "security.c" file.  The access control list is turned off by default.  The access control list has the ability to restruct who has subscribe/publish privileges per topic.

  
