# Summary of Observations

We analyzed the threat list generated by the TMT prorgram in order to determine if these threats are already mitigated in mosquitto.  Below are our findings after reviewing the mosquitto documentation and performing a code review.

## Spoofing: 
Mosquitto does have username/password authentication built in.  If the username/password feature is enabled, there are two ways to setup the credentials: 
* A system admin can do this manually.  If they do this, they still need to use the `mosquitto_passwd` utility with the `-U` option in order to hash the passwords in the file. 
* Use the `mosquitto_passwd` utility to manage the file. This utlility can create and update the password file.

The password utility must be performed on the same machine as the mosquitto broker.  It does not allow remote access since it is not exposed to the open internet.  This is a good security mechanism which prevents a significant amount of potential attack vectors.

Mosquitto has a strict format for the password file.  Each line must only have 1024 bytes worth of characters. This strict format is important because it prevents buffer overflows within the code.  Any line in the password file, or username/password argument passed into the "mosquitto_passwd" utility, that is longer than 1024 characters will be cut off when read by the mosquitto_passwd program.  This length is specified in the `MAX_BUFFER_LEN` preprocessor in the "moquitto_passwd.c" file, and it is referenced repeatedly througout the file, including in the `delete_pwuser` function, `update_pwuser` function, and the `get_password` file.   

Mosquitto does provide the “allow_anonymous”  configuration flag to enforce a “closed system.” 

One of our findings was that mosquitto does not require strong passwords.  This leaves open the possibility for a brute force attack.  

Mosquitto also supports dual factor authentication.  In addition to username/password authentication, the system admin can also setup pre-shared-key based encryption.  

## Tampering:
We saw evidence throughout the project that input validation is repeatedly enforced in order to prevent the possability of buffer overflows.   Methods associated with buffer overflows because they do no bounds checking, `gets()`, `scanf()` and `strcpy()`, are not referenced anywhere in the repository.  The method `strcat()` which does no bounds checking is referenced twice in the "service.c" file, but it is safe because the argument in question is a predetermined string literal.  The code makes good use of methods that require an argument to be passed for the length of data structures,  such as: `calloc()`, `memcpy()`, and `strncpy()`. Two files of particular interest for tampering purposes is the "handle_publish.c" file and the "handle_subscribe.c" file.  Buffer Overflow preventions are present in both files.  Specifically, lines 155, 156, 157, 138-145 in "handle_publish.c," and lines 52, 139 on "handle_subscribe.c."  

## Repudiation:
Mosquitto enforces the MQTT feature of "Quality of Service".  Quality of Service refers to how hard Mosquitto will work to deliver the message to subscribers.  For purposes of mitigating repudiation, level 1 and level 2 would be considered the best strategies.  Level one will continue sending the message until a confirmation is receieved, and Level 2 sends the message exactly once, but a four step handshake establishes a connectiona nd acknwledges that the data was received. 

## Information Disclosure:
Information disclosure attacks are mitigated with built-in support for network level encryption via SSL/TLS support. This configuration is disabled by default and must be setup by the system admin. 

## Denial of Service
In the Denial of Service category, Mosquitto especially shines due to it's lightweight architecture, size of messaging and requests, and zealous handling of memory management and input validation while prosseses iterate. An example of this can be found in [handle_publish.c](https://github.com/eclipse/mosquitto/blob/master/src/handle_publish.c), every possible outcome through the handle\_\_publish function eventually hits the mosquitto_free call with the char pointer topic (which is defined in [memory_mosq.c](https://github.com/eclipse/mosquitto/blob/master/lib/memory_mosq.c)). Everytime the mosquitto\_\_free function is called, it tracks how many available memory blocks are used throughout the project in the memcount variable (also defined in [memory_mosq.c](https://github.com/eclipse/mosquitto/blob/master/lib/memory_mosq.c)), and in the other function, mosquitto\_\_malloc. That way, if the memcount variable is greater than the maximum amount allowed by mosquitto, the mosquitto\_\_malloc function returns null, which would then set off memory limit errors within [mosquitto.c](https://github.com/eclipse/mosquitto/blob/master/src/mosquitto.c), [loop.c](https://github.com/eclipse/mosquitto/blob/master/src/loop.c), and [handle_publish.c](https://github.com/eclipse/mosquitto/blob/master/src/handle_publish.c), closing the broker down.

Despite this, a massive Denial of Service attack could still be attempted against a Mosquitto broker, which is why configuration options such as the ability to limit repeated messages from the same user ([mosquitto conf manpage](https://mosquitto.org/man/mosquitto-conf-5.html), see allow_duplicate_messages option) and setting a QoS of 2 to ensure that a message being sent to the broker is received exactly once ([MQTT protocol Qos Features](https://www.hivemq.com/blog/mqtt-essentials-part-6-mqtt-quality-of-service-levels)) can be enabled (note, the QoS levels aren't specific to Mosquitto, they are defined in the MQTT standards).

Combining these features with a separation of specific users for processes that cross boundaries of trusts would ensure that data stores referenced by mosquitto processes aren't being blocked by external authorities. This currently is not supported in mosquitto, in that all processes for mosquitto are handled by the same user (defined in [mosquitto.conf](https://mosquitto.org/man/mosquitto-conf-5.html) man page in "user" config option).

## Elevation of Privilege
Mosquitto protects against elevation of privilege attacks by implementing an access control list.  The major access control list functions are located in the "security.c" file.  The access control list is turned off by default.  The access control list has the ability to restruct who has subscribe/publish privileges per topic.

  
